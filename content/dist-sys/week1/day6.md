+++
date = '2026-01-30T08:45:32+08:00'
draft = false
title = 'Week1 Day6'
+++
## Day 6: 缓冲 I/O 与跨平台交付

1. Buffered I/O
    - [bufio](https://golang.google.cn/pkg/bufio/): Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer object, creating another object (Reader or Writer) that also implements the interface but provides buffering and some help for textual I/O.(Decorator Pattern)
        - `bufio` 在用户态维护一个缓冲区（默认为 4KB）。它一次性从内核“批发”一大块数据到内存, 然后在内存里慢慢“零售”, 数据从内核到内存通过[`func (b *Reader) fill()`](https://golang.google.cn/src/bufio/bufio.go#L99)实现
    - [`bufio.Scanner`](https://golang.google.cn/pkg/bufio/#Scanner)
        - Scanner provides a convenient interface for reading data such as a file of newline-delimited lines of text. Successive calls to the Scanner.Scan method will step through the 'tokens' of a file, skipping the bytes between the tokens. The specification of a token is defined by a split function of type SplitFunc; the default split function breaks the input into lines with line termination stripped. Scanner.Split functions are defined in this package for scanning a file into lines, bytes, UTF-8-encoded runes, and space-delimited words. The client may instead provide a custom split function.(Token指根据SplitFunc执行分割逻辑后的数据)
            - [`SplitFunc`](https://golang.google.cn/pkg/bufio/#SplitFunc): SplitFunc is the signature of the split function used to tokenize the input. The arguments are an initial substring of the remaining unprocessed data and a flag, atEOF, that reports whether the Reader has no more data to give. The return values are the number of bytes to advance the input and the next token to return to the user, if any, plus an error, if any. 
                > `type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)`
            - [`Scanner.Scan`](https://golang.google.cn/pkg/bufio/#Scanner.Scan): Scan advances the Scanner to the next token, which will then be available through the `Scanner.Bytes` or `Scanner.Text` method. It returns false when there are no more tokens, either by reaching the end of the input or an error.
                > `func (s *Scanner) Scan() bool`
                > 
                > [Scan](https://golang.google.cn/src/bufio/scan.go?s=6140:6169#L129)中调用split方法获取token等字段
            - [`Scanner.Text`](https://golang.google.cn/pkg/bufio/#Scanner.Text): Text returns the most recent token generated by a call to Scanner.Scan as a newly allocated string holding its bytes.
                > `func (s *Scanner) Text() string`
        - Scanning stops unrecoverably at EOF, the first I/O error, or a token too large to fit in the Scanner.Buffer. When a scan stops, the reader may have advanced arbitrarily far past the last token. **Programs that need more control over error handling or large tokens, or must run sequential scans on a reader, should use `bufio.Reader` instead**.
        - The simplest use of a Scanner, to read standard input as a set of lines.
            ```go
            package main

            import (
                "bufio"
                "fmt"
                "os"
            )

            func main() {
                scanner := bufio.NewScanner(os.Stdin)
                for scanner.Scan() {
                    fmt.Println(scanner.Text()) // Println will add back the final '\n'
                }
                if err := scanner.Err(); err != nil {
                    fmt.Fprintln(os.Stderr, "reading standard input:", err)
                }
            }
            ```
    - [`bufio.Reader`](https://golang.google.cn/pkg/bufio/#Scanner): Reader implements buffering for an io.Reader object. A new Reader is created by calling NewReader or NewReaderSize; alternatively the zero value of a Reader may be used after calling [Reset] on it.
        - [`Reader.ReadBytes`](https://golang.google.cn/pkg/bufio/#Reader.ReadBytes): ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient.
            > `func (b *Reader) ReadBytes(delim byte) ([]byte, error)`
    - Scanner中一个token的最大大小为[MaxScanTokenSize](https://golang.google.cn/src/bufio/scan.go#L82)=64KB, Scanner 必须把整个 Token 完整地放进内部的 buffer 里才能返回, 对于大小超过64KB的Token, Scanner 会直接报错 `bufio.ErrTooLong`, 此时可以[`Scanner.Buffer`](https://golang.google.cn/pkg/bufio/#Scanner.Buffer)手动扩容来解决;
     
        或者用`bufio.Reader`的`Reader.ReadBytes`方法(因为方法内部一直[append](https://golang.google.cn/src/bufio/bufio.go#L466), 存在OOM风险)
    
        最佳实践是使用 [`Reader.Read`](https://golang.google.cn/pkg/bufio/#Reader.Read) 配合固定大小的缓冲区进行流式处理（Streaming）, 在读取的数据块中手动寻找边界([`bytes.IndexByte`](https://golang.google.cn/pkg/bytes/#IndexByte))
    - `bufio.Reader` 和 `bufio.Scanner`
        - `bufio.Reader` ( The Low-Level Powerhouse): 通用的、底层的流读取器; 赋予开发者对 I/O 的绝对控制权。它可以读字节、读字符串、读行、读固定长度块。它不假设数据的格式，只负责高效搬运
        - `bufio.Scanner` (The High-Level Iterator): 专用的、便捷的分词器 (Tokenizer); 在处理“由分隔符切分的数据流”（如行、单词）时隐藏了复杂的缓冲区管理逻辑（如数据搬运、扩容）, 提供简单的迭代接口

2. 标志位解析 (Flag Parsing)
    > Go 的 flag 继承的是 Plan 9 操作系统 的风格，而不是 Linux 常见的 GNU 风格
    >
    > |特性|GNU 风格 (getopt)|Go/Plan 9 风格 (flag)|
    > |-|-|-|
    > |短/长参数|区分 -v (短) 和 --verbose (长)|不区分。-v 和 --v 是一样的，-verbose 和 --verbose 也是一样的|
    > |组合参数|支持 -rm (等同于 -r -m)|不支持。-rm 会被视为一个名字叫 rm 的 flag|
    > |赋值方式|-p 8080 或 --port=8080|-p 8080 或 -p=8080 (推荐后者，无歧义)|
    > |布尔值|-d 即为真|-d 即为真。但如果你写 -d false，必须用等号 -d=false，否则 false 会被当成下一个非 flag 参数|
    - [flag](https://golang.google.cn/pkg/flag/): Package flag implements command-line flag parsing.
        - Usage
            1. Define flags using flag.String, Bool, Int, etc.
                > For such flags, the default value is just the initial value of the variable.
                - `var nFlag = flag.Int("n", 1234, "help message for flag n")`: This declares an integer flag, -n, stored in the pointer nFlag, with type `*int`:
                - ```go { title="If you like, you can bind the flag to a variable using the Var() functions." }
                  var flagvar int
                  func init() {
                      flag.IntVar(&flagvar, "flagname", 1234, "help message for flagname")
                  }
                  ```
                - Or you can create custom flags that satisfy the Value interface (with pointer receivers) and couple them to flag parsing by `flag.Var(&flagVal, "name", "help message for flagname")`
            2. After all flags are defined, call `flag.Parse()` to parse the command line into the defined flags. Flags may then be used directly. If you're using the flags themselves, they are all pointers; if you bind to variables, they're values.
            3. After parsing, the arguments following the flags are available as the slice flag.Args or individually as flag.Arg(i). The arguments are indexed from 0 through flag.NArg-1.
        - [`Bool`](https://golang.google.cn/pkg/flag/#Bool): Bool defines a bool flag with specified name, default value, and usage string. The return value is the address of a bool variable that stores the value of the flag.
            > `func Bool(name string, value bool, usage string) *bool`
            > 
            > name为flag名称, value为默认值, usage 用于生成 -h 帮助文档
        - [`Parse`](https://golang.google.cn/pkg/flag/#Parse): Parse parses the command-line flags from os.Args[1:]. Must be called after all flags are defined and before flags are accessed by the program.
            > `func Parse()`
        - [`Args`](https://golang.google.cn/pkg/flag/#Args): Args returns the non-flag command-line arguments.
            > `func Args() []string`

3. 交叉编译 (Cross-Compilation)
    - Go 的工具链不仅是一个编译器，还是一个链接器。它支持“一次编写，到处编译”。通过设置环境变量 `GOOS` (操作系统) 和 `GOARCH` (架构) 可以在 WSL2 (Linux) 上瞬间编译出 Windows 的 `.exe` 或 macOS 的二进制文件，且无需安装任何额外工具
    - 可以通过命令 `go tool dist list` 查看所有支持的组合

4. 工程实践：`cat.go` v1.1, 带有 `-n` 功能(显示行号)
    - 遵循的 Go/Plan 9 操作系统的风格 command [options] [arguments]
    - 
    ```go
    package main

    import (
        "bufio"
        "flag"
        "fmt"
        "io"
        "os"
    )

    // ---------------------------------------------------------
    // 全局配置：使用 flag 包定义命令行参数
    // ---------------------------------------------------------
    var (
        // 定义 -n 参数，默认值为 false
        nFlag = flag.Bool("n", false, "number all output lines")
        line  = 1
    )

    // ---------------------------------------------------------
    // Helper 1: 原始拷贝 (Fast Path)
    // Day 5 的成果，用于不带 -n 的情况
    // ---------------------------------------------------------
    func runRawCopy(r io.Reader) error {
        _, err := io.Copy(os.Stdout, r)
        return err
    }

    // ---------------------------------------------------------
    // Helper 2: 带行号拷贝 (Buffered Path)
    // TODO: 使用 bufio 处理文本流
    // ---------------------------------------------------------
    func runWithLineNumbers(r io.Reader) error {
        scanner := bufio.NewScanner(r)

        // the default split function breaks the input into lines with line termination stripped.
        // 输出端也可以缓冲
        // out := bufio.NewWriter(os.Stdout)
        // fmt.Fprintf(out, "%6d\t%s\n", line, scanner.Text())
        // defer out.Flush()
        for scanner.Scan() {
            fmt.Printf("%6d\t%s\n", line, scanner.Text())
            line++
        }

        return scanner.Err()
    }

    func main() {
        flag.Parse()

        // 获取非 Flag 的参数 (即文件名列表)
        // flag.Args() 返回的是解析掉 -n 剩下的参数
        filenames := flag.Args()

        // 逻辑分发：如果没有文件参数，读 Stdin
        if len(filenames) == 0 {
            processStream(os.Stdin)
            return
        }

        // 遍历文件
        for _, fname := range filenames {
            if fname == "-" {
                processStream(os.Stdin)
            } else {
                f, err := os.Open(fname)
                if err != nil {
                    fmt.Fprintf(os.Stderr, "go-cat: %s: %v\n", fname, err)
                    continue
                }
                // 处理文件流
                processStream(f)
                f.Close()
            }
        }
    }

    // processStream 根据全局 nFlag 决定调用哪个处理函数
    func processStream(r io.Reader) {
        var err error

        if *nFlag {
            err = runWithLineNumbers(r)
        } else {
            err = runRawCopy(r)
        }

        if err != nil {
            fmt.Fprintln(os.Stderr, err)
        }
    }

    ```

5. 验证功能
    ```console { title="不显示行号" }
    $ echo "Hello from Pipe" | go run cat.go no_exist.txt test1.txt - test2.txt
    go-cat: no_exist.txt: open no_exist.txt: no such file or directory
    hello
    Hello from Pipe
    world!
    ```
    ```console { title="显示行号" }
    echo "Hello from Pipe" | go run cat.go -n no_exist.txt test1.txt - test2.txt
    go-cat: no_exist.txt: open no_exist.txt: no such file or directory
        1  hello
        2  Hello from Pipe
        3  world!
    ```

6. 通过交叉编译生成一个 `.exe` 文件并验证功能
    > 显式相对路径执行 (Explicit Relative Path Execution) `./go-cat.exe`
    > 
    > Shell 不会在“当前目录”找命令(防止 特洛伊木马攻击), Bash Shell 会按照以下步骤工作
    >   1. 检查别名 (Alias)：有没有叫这个名字的别名？
    >   2. 检查内置命令 (Built-in)：这是不是 cd 或 echo 这种内置命令？
    >   3. 查询 $PATH (核心关键)：Shell 会遍历环境变量 $PATH 中定义的一系列目录（比如 /bin, /usr/bin, /usr/local/bin）。
    >   4. 找不到报错：如果这些目录里都没有 go-cat.exe，它就直接报错 command not found
    `GOOS=windows GOARCH=amd64 go build -o go-cat.exe cat.go`
    ```console { title="不显示行号" }
    $ echo "Hello from Pipe" | ./go-cat.exe no_exist.txt test1.txt - test2.txt
    go-cat: no_exist.txt: open no_exist.txt: no such file or directory
    hello
    Hello from Pipe
    world!
    ```
    ```console { title="显示行号" }
    echo "Hello from Pipe" | ./go-cat.exe -n no_exist.txt test1.txt - test2.txt
    go-cat: no_exist.txt: open no_exist.txt: no such file or directory
        1  hello
        2  Hello from Pipe
        3  world!
    ```